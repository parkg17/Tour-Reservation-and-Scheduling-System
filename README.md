# Tour-Reservation-and-Scheduling-System

가) Role of each member

	- UI 및 전체적인 알고리즘 구상
	- 그래프 최단 경로 알고리즘 구상
	- 소스 코드와 헤더 파일 모듈화
	- DFS.c 구현
	- mainUI.c 구현
	- UserInfo.c 구현
	- UI.c 구현
	- RBTree.c 코드 구현
	- Graph_List.c 코드 구현
	- Input 및 Output 디자인 및 콘솔 입출력 구현
	- 최종 보고서 작성
	- 프로그램 주석 관리
	- 프로그램 디버깅

나) Introduction

 1) 전반적인 코드 소개

 아래 코드는 알고리즘 최종 프로젝트인 “Tour reservation and scheduling system”을 구현한 코드입니다. 코드를 시작하는 있어서 먼저 City들을 생성합니다. 도시는 0~99 총 100개의 도시(vertex)가 생성되며, 도시를 잇는 간선(edge)들은 출발지와 도착지가 각각 랜덤으로 생성되어서 총 300개의 도시를 잇는 간선(edge)을 생성합니다. 이 간선들은 System의 부하를 줄이기 위해서 양방향이 아닌 단방향으로 설정합니다. 또한, 도시들 간에는 거리가 있으며, 각 도시마다 다른 이동 수단을 사용한다고 고려하여서 각 이동 수단마다 서로 다른 가격을 가집니다. 또한 각각의 도시마다 100개의 호텔을 갖으며, 호텔에 대한 정보는 RBtree에 저장됩니다.
 
 사용자에 입장에서는 예약을 위해서  사용자로부터 ID, Budget, 시작 도시, 도착 도시, 여행 기간, 원하는 호텔의 퀄리티를 입력받습니다. 그러면 시스템은 해당 정보를 입력받고, 사용자의 예산과 여행 기간을 고려하여서 DFS를 통해 알맞은 여행 정보를 출력합니다. 여기서 DFS 즉, 깊이우선탐색은 최적의 경로를 하나만 제공하는 것이 모든 경로를 다 탐색해 본 다음 최적의 결과를 제공합니다. 마지막으로, 예약을 마친 경우, 사용자는 UI를 이용해서 자신의 예약 정보를 확인할 수 있습니다.


 2) 전반적인 알고리즘 소개

 먼저 하루에 한 도시를 둘러본다고 가정합니다. 만약 여행기간이 6일이라고 하면 총 6개의 도시를 둘러볼 것입니다. 따라서 최대로 거칠 수 있는 도시의 수는 6개가 되며, 이는 DFS가 모든 탐색을 하는데 있어서 더 빠른 시간 내에 결과를 출력할 수 있게 도와줍니다. 또한, 호텔이나 이동 수단의 경우, n개의 도시를 지나는 동안 n-1번씩만 필요합니다. 위의 예시에서 호텔의 경우 마지막 날은 이용하지 않으므로 6개의 도시를 지나는 동안 5번만 이용하며, 이동 수단의 경우 첫날에는 해당 도시에 있기 때문에 5번만 이용하면 됩니다.
 
 이제 DFS 알고리즘으로 건너가면, DFS는 위에서 말했다시피 n개의 도시를 지나는 모든 경로에 해당하는 경우의 수를 고려합니다. 단, DFS를 실행하면서 현재 도착 도시가 사용자가 입력한 도착 도시와 일치하는 경우에만 Check_Path() 함수를 통해 경로가 추천할 만한 경로인지 확인합니다. Check_Path() 함수는 경로를 지나가면서 사용자가 입력한 호텔 퀄리티의 선호정도를 고려하면서 예산에 합당하는지 검사합니다. 자신의 예산에 대해서 매 도시마다 호텔의 가격과 이동 수단을 이용할 때의 가격을 차감합니다. 최종적으로 예산이 0보다 크면 해당 경로는 여행경로로 추천하며 탐색을 종료하고, 그렇지 않으면 여행경로를 계속해서 탐색합니다.



다) User interface and modules description

 1) Input, Output 화면

  기본적인 UI는 다음과 같습니다. 1번째 선택지는 사용자의 정보를 입력받고 예약을 담당하는 부분이고, 2번째는 예약한 사용자의 정보와 예약 현황을 확인할 수 있는 부분입니다. 마지막 3번째는 해당 프로그램의 설명과 조작키를 설명하는 부분입니다.

  도움말은 다음과 같습니다. 기본적으로 방향키 4개(↑, ↓, ←, →)와 엔터키만으로 프로그램을 조작할 수 있습니다.

  첫 번째 선택지는 예약을 하는 화면입니다. 여기서 사용자는 자신의 ID, 예산, 시작 도시, 도착 도시, 여행 기간, 그리고 선호하는 호텔의 퀄리티(1성급 ~ 5성급)를 입력할 수 있습니다. 

  두 번째 선택지는 예약을 확인하는 화면입니다. 예약을 성공하면 해당 도시와 각각의 호텔 가격이 출력됩니다. 

 2) 코드 모듈화

  코드는 다음과 같이 모듈화되어 있습니다. Header.h 헤더파일에는 코드에 사용된 각종 라이브러리와 여러 헤더파일에 대한 정보가 들어있고, 나머지 각종 헤더파일에는 각 소스코드에 대한 구조체 선언이나 함수 선언, 상수 선언 등에 대한 정보가 들어있습니다.
  각 코드에 대해서 간략히 설명하면 다음과 같습니다.

 1. DFS.c
 
그래프에서 최적 경로를 찾기 위한 깊이 우선 탐색에 대한 코드와 그에 필요한 여러 함수들 (즉, 스택에 관련된 함수나 경로가 최적인지 판단하는 함수들)이 들어 있는 소스 코드입니다.

 2. Graph_List.c

인접 리스트로 구현한 그래프에 대한 정보가 들어있습니다. 그래프들의 vertex는 City 이름이며, 그래프들의 edge는 City 사이의 거리(혹은 특정 이동 수단에 대한 cost)가 저장되어 있습니다. 그래프는 단뱡향 그래프이기 때문에 인접 리스트를 구현할 때 있어서 한쪽 방향으로만 vertex에 해당하는 node를 입력합니다.

 3. main.c

프로그램의 메인함수입니다. 방향키나 엔터를 입력받으면 메인에서 처리해주어서 각종 함수를 실행하거나 입력 값에 알맞은 화면은 UI.c에서 가져와 출력하여 사용자에게 제공합니다.

 4. RBTree.c

호텔의 정보를 저장하기 위한 레드 블랙 트리에 관련된 소스 코드입니다. 각 도시마다 호텔이 100개씩 저장되어 있는 레드 블랙 트리를 갖습니다.

 5. UI.c

프로그램의 시작 화면이나 Output을 보여주는 UI에 대한 정보를 저장합니다. 

 6. UserInfo.c

사용자의 정보를 저장하고 처리해주는 함수가 저장되어 있습니다.


라) Extensive execution examples and analysis
 
 1) 확장한 기능

 예산에 대해서 설명하면, 예산은 $기준으로 고려하였으며, 일단 이동 수단의 개수는 300개이고 각각의 cost 범위는 $100 ~ 399 로 1단위씩 다르게 랜덤 함수를 이용하여 설정하였습니다.
 호텔 값의 경우, $50 ~ 1040 까지 10단위로 총 100개의 서로 다른 가격대를 가진 호텔을 고려하였으며, 사용자가 자신의 정보를 입력하면서 선호하는 호텔의 퀄리티 정보 또한 입력합니다. 여기서 호텔의 퀄리티는 총 1성급부터 5성급까지로 고려하였으며, 각각 다음과 같습니다.

1성급 : ($)50 ~ 150
2성급 : ($)160 ~ 300
3성급 : ($)310 ~ 550
4성급 : ($)560 ~ 800
5성급 : ($)810 ~ 1040

만약 사용자가 3성급을 입력하였다면 $310~550 사이의 호텔 가격을 갖는 호텔을 추천해주며, 만약 호텔에 대해 딱히 상관없다면 1~5 대신 0을 입력하여서 호텔 가격의 범위를 아무렇게나 설정할 수 있습니다.

 2) 확장 가능성

 1. 현재 한 사용자에 대해 하나의 추천 경로만을 보여주지만, 경로 버퍼의 크기를 늘려서 사용자에게 5개 정도의 경로를 보여준 다음, 사용자가 직접 선택하도록 확장할 수 있음.

 2. 사용자의 입력 정보를 지움으로써 예약 정보를 취소할 수 있게 확장할 수 있음.

 3. 아직 입력하는 부분을 완성하지 못하여서 일단 main.c에 37줄부터 47줄에 직접 유저 정보를 입력하여서 프로그램을 실행하였음. 
